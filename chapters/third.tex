	\chapter{Steganografia e LSB-modification}
La steganografia è l'arte di nascondere informazioni in file multimediali senza sollevare alcun sospetto da parte di un attaccante esterno. Essa comprende un'ampia varietà di tecniche utili a nascondere l'esistenza stessa del messaggio. In questo elaborato si assumerà che le cover usate siano immagini.\\Per un computer un'immagine è una sequenza di valori che rappresentano l'intensità luminosa in uno specifico punto o pixel. I pixel vanno a formare il dato \textit{raster} dell'immagine, ovvero una matrice di valori che la descrive completamente e ne permette la visualizzazione su uno schermo.\\Le immagini digitali sono memorizzate in formati che differiscono fra loro nel numero di byte per pixel usati per rappresentare un valore tonale. I due tipi di immagini digitali principali sono 24-bit e 8-bit \cite{seeingTheUnseen}. Tutte le variazioni di colore sono derivate dai tre colori primari: rosso, verde e blu. Nel formato a 24 bit ogni colore primario è rappresentato da un byte e, di conseguenza, il valore tonale di un pixel sarà dato dalla combinazione dei valori di 3 byte. La rappresentazione del pixel influisce sulla dimensione del file e quindi sulla sua capacità di memorizzazione. Nonostante le immagini a 24 bit offrano un maggiore spazio di memorizzazione, sono ancora poco comuni nel Web, quindi attraggono maggiormente l'attenzione se usate in una comunicazione steganografica. Per questo motivo, a meno che non si disponga di metodi di compressione adeguati, si preferisce utilizzare come cover immagini a 8 bit. In questo tipo di immagini ogni pixel è rappresentato da un singolo byte il cui valore altro non è che un puntatore ad una tabella contenente la gamma dei colori disponibili, anche chiamata \textit{tavolozza} o \textit{palette}. Il valore del pixel varia nell'intervallo $[0, 255]$. Il software di visualizzazione, nel momento della stampa dell'immagine a schermo, userà semplicemente il colore associato al valore del pixel nella tavolozza.\\
Di seguito è riportato un generico processo steganografico:

Come mostra la fig. 3.1, affinché possa avvenire una comunicazione steganografica, è necessario scegliere un file cover adeguato all'interno del quale incapsulare il messaggio \textit{m}. Gli esperti concordano nel raccomandare l'utilizzo di immagini ad 8 bit in scala di grigi a 256 sfumature \cite{experts} in quanto, come mostra la fig. 3.2, le variazioni tonali avvengono in modo molto graduale di byte in byte.

Nella scelta della cover bisogna tener conto non solo della tavolozza, ma anche della morfologia e geometria dell'immagine stessa. Se infatti l'immagine dovesse presentare numerose aree di colore \virgolette{solido}, senza sfumature, le variazioni tonali introdotte dalla scrittura di un messaggio in quelle aree risulterebbero facilmente distinguibili anche ad occhio nudo.\\Nella fase successiva alla scelta della cover verrà generata una stego-chiave pseudo-casuale, che servirà a scegliere i pixel che conterranno il messaggio. Si deciderà poi il metodo di incapsulamento da utilizzare. Per nascondere un messaggio all'interno della cover scelta esistono tre approcci principali:
\begin{itemize}
\item le tecniche di \textbf{LSB-modification} prevedono l'inserimento del messaggio direttamente nell'insieme dei bit meno significativi di ogni pixel;
\item nei metodi di \textbf{masking} e \textbf{filtering} i valori dei pixel delle aree scelte per incapsulare il messaggio subiscono incrementi e decrementi in percentuale, rendendo così le modifiche impercettibili ad occhio nudo;
\item l'ultimo macro-insieme di metodologie prende il nome di \textbf{Transform Domain}. Questi metodi nascono con l'intento di rendere le tecniche di \textit{LSB-modification} più robuste \cite{seeingTheUnseen} limitando la potenziale perdita di dati durante una compressione o un \textit{post-processing} dello stego-oggetto.
\end{itemize}
Una volta scelto il metodo di incapsulamento del messaggio si può procedere alla trasmissione vera e propria.
Verrà ora presentata la metodologia di \textit{LSB-modification}.
		\section{LSB-modification}
Le tecniche di LSB-modification sono anche conosciute come metodi di \textit{steganografia spaziale}. Esse operano cambiando direttamente il valore del pixel dell'immagine per nascondere il messaggio scelto, sfruttando l'impercettibilità di tale variazione all'occhio umano \cite{warfare}.

La figura precedente fornisce un esempio di applicazione di un approccio LSB basilare. Sulla sinistra vi sono i \textit{bit-plane} di una generica figura in scala di grigi con il \textit{Most-Significant-Bit plane} in cima e l'LSB-plane in fondo.\\I rettangoli scuri e chiari rappresentano bit con valore rispettivamente uguale a zero e uno. In alto a destra vi è il piano LSB della cover, al di sotto di esso vi è un piano di bit che rappresenta il messaggio che verrà incorporato sostituendo completamente il piano LSB della cover. Il riquadro in basso a destra mostra infine quali bit hanno effettivamente cambiato il loro valore successivamente all'incapsulamento.\\Vediamo ora un esempio più pratico: sia $I$ un'immagine a 24 bit, poiché ogni pixel è rappresentato da 3 byte, l'\textit{LSB-plane} di $I$ è formato dall'insieme dei tre bit meno significativi di ogni pixel. All'interno di $I$ è quindi possibile incapsulare 3 bit per ogni pixel. Si supponga ora di voler nascondere all'interno dell'LSB-plane di $I$, con la tecnica di LSB-modification, un messaggio $m$ contenente la sola lettera \virgolette{A} con codifica binaria $\mathtt{10000011}$. Assumendo che $m$ non venga compresso, si procederà nel seguente modo: sia $r$ il dato raster di $I$ riferito ai tre pixel scelti per nascondere $m$, con
\begin{equation}
\notag
\begin{split}
r= \; &(\mathtt{00100111} \quad \mathtt{11101001} \quad \mathtt{11001000})\\&(\mathtt{00100111} \quad \mathtt{11001000} \quad \mathtt{11101001})\\&(\mathtt{11001000} \quad \mathtt{00100111} \quad \mathtt{11101001})
\end{split}
\end{equation}
l'inserimento di $m$ in $r$ avrà come risultato un nuovo dato raster
\begin{equation}
\notag
\begin{split}
r_1= \; &(\mathtt{00100111^*} \quad \mathtt{1110100\underline 0 ^*} \quad \mathtt{11001000^*})\\&(\mathtt{0010011\underline 0 ^*} \quad \mathtt{11001000^*} \quad \mathtt{1110100\underline 0 ^*})\\&(\mathtt{1100100\underline{1}^*} \quad \mathtt{00100111^*} \quad \mathtt{11101001})
\end{split}
\end{equation}
dove i bit sottolineati sono gli unici quattro che hanno cambiato valore rispetto agli 8 utilizzati per nascondere il messaggio, contrassegnati con un asterisco. %Scelto l'insieme dei pixel in cui verrà nascosto il messaggio, il processo di incapsulamento della steganografia LSB può essere descritto dalla seguente equazione:
%			\[y_i=2\lfloor \frac{x_i}{2} \rfloor +m_i\]
%dove $m_i$, $x_i$ e $y_i$ sono rispettivamente l'i-esimo bit del messaggio, il valore dell'i-esimo pixel scelto prima dell'incapsulamento e il valore dell'i-esimo pixel scelto dopo l'incapsulamento.
La steganografia basata sulle modifiche agli LSB-plane cambia in media il valore di al più la metà dei bit scelti, introducendo un rumore, misurato in \textit{peak-signal-to-noise ratio}\footnote{Il \textit{peak-signal-to-noise ratio} misura la qualità di una immagine compressa rispetto all'originale. $\mathrm{\grave{E}}$ definito come il rapporto tra la massima potenza di un segnale e la potenza di rumore che può invalidare la fedeltà della sua rappresentazione compressa ed è espresso in termini di scala logaritmica di decibel.} rispetto alla cover, pari a 51.1dB. Considerata la soglia minima accettata dalla comunità scientifica di 39dB, il rumore introdotto dalle variazioni consente di avere comunque un alto grado di impercettibilità \cite{seeingTheUnseen, warfare}.\\Le tecniche di LSB-modification, nella loro implementazione più basilare, sono quindi un modo, seppur semplice, per nascondere un messaggio in un'immagine introducendo un numero \textit{trascurabile}, se non nullo, di distorsioni percepibili.
\subsection{Sicurezza dei metodi di LSB-modification}
Sebbene l'LSB-modification sia una tecnica molto semplice ed immediata ha un alto grado di impercettibilità visiva e, come si vedrà in questa sezione, può essere considerata sicura secondo la definizione \ref{sistemaSicuro1}.
Per dimostrare la sicurezza condizionale di un sistema steganografico $S$ che usi come funzione di incapsulamento la tecnica di LSB-modification bisogna far ricorso alla tecnica di dimostrazione per assurdo combinata con quella di \textit{riduzione}\footnote{Una riduzione è una funzione $f$ che trasforma un problema $A$ in un altro problema $B$ mantenendone
inalterate la caratteristiche principali.}. La dimostrazione che segue dapprima trasformerà il problema dell'attacco al cifrario RSA (problema considerato computazionalmente intrattabile) nel problema della decisione steganografica su $S$ e, successivamente, proverà che, qualora $S$ dovesse non essere sicuro secondo la definizione \ref{sistemaSicuro1}, questo equivarrebbe a dire che il problema dell'attacco all'RSA è trattabile, che ovviamente rappresenta un assurdo.\\Sia $n$ il \textit{modulo}\footnote{Un modulo per l'RSA è un numero $n = p \cdot q$ con $p$ e $q$ numeri primi grandi e distinti.} dell'RSA. Si assuma inoltre che tutti i messaggi scambiati nella comunicazioni siano elementi di $\mathbb{Z}_n$. Un sistema steganografico $S \, = \, \langle G,E,D\rangle$ sarà quindi descritto nel seguente modo:
\begin{itemize}
\item[a)] L'algoritmo $G$ diventa la funzione di generazione della chiave pubblica dell'RSA che prende in input $1^l$, con $l$ lunghezza della chiave da generare, e restituisce la tripla $\langle e, d, n\rangle$, dove $\Vert n\Vert \, = \, l$ e vale che
\[ ed \, \equiv \, 1 \quad \mathrm{mod}(p-1)(q-1) \]
\item[b)] L'insieme delle cover sarà formato da tutte le stringhe cifrate con l'RSA tali che la loro codifica binaria in chiaro termina con uno zero, mentre l'insieme degli stego-oggetti contiene le stringhe cifrate con l'RSA tali che la loro codifica binaria in chiaro termina con un uno.
\item[c)] L'algoritmo di incapsulamento $E$ prende il messaggio $m$ che si vuole inserire nella cover, vi aggiunge un uno alla fine della sua codifica binaria, esegue operazioni di \textit{padding} e copia $m$ nell'LSB della cover dopo averlo cifrato.
\item[d)] L'algoritmo $D$ invece, oltre alla decodifica del potenziale stego-oggetto, controlla qualora la codifica binaria del suo LSB in chiaro termini con uno zero. Se ciò avviene i rimanenti bit corrisponderanno al messaggio incapsulato, altrimenti saranno una sequenza senza significato.
\end{itemize} 
$\mathrm{\grave{E}}$ noto che calcolare il valore del bit meno significativo di una stringa binaria cifrata con l'RSA equivale a violare il cifrario \cite{sec}. Sotto questa assunzione verrà provato che $S$, costruito come sopra, deve essere probabilisticamente sicuro. Se così non fosse l'algoritmo di decodifica di $S$ potrebbe essere usato come \textit{oracolo} contro l'RSA, il che equivarrebbe a dire di aver trovato un attacco probabilistico e polinomiale all'RSA, cosa creduta attualmente computazionalmente intrattabile.
Si assuma quindi che $S$ non sia probabilisticamente sicuro, quindi esiste un gioco probabilistico $P$ fra uno steganalista e un giudice tale che il primo è in grado di decidere, dato un elemento di $\mathbb{Z}_n$, se è una cover o uno stego-oggetto.\\
Da qui in avanti, se $s$ è una generica stringa binaria, si indicherà con $s_0$ il valore del suo bit meno significativo.\\Sia $x \in \mathbb{Z}_n$ un testo cifrato con l'RSA e $y = x^d \, \mathrm{mod} \, n$ il corrispondente testo in chiaro, definiamo ora una algoritmo $P_1$ che simula il gioco probabilistico $P$. Se lo steganalista fa una richiesta per una cover $c_i$, $P_1$ sceglie, in modo casuale, una stringa $y_i$ tale che $y_{i_0} = 0$, la cifra e la restituisce come risultato dell'oracolo steganografico di $S$. Analogamente, se viene richiesto uno stego-oggetto contenente un messaggio $m_i$, $P_1$ incapsula $m_i$ in una cover con $E$ e restituisce il risultato del processo di \textit{embedding}, ovvero il testo cifrato $x$, come se fosse la risposta dell'oracolo di valutazione strutturale di $S$.\\Poiché è stata fatta l'ipotesi che $S$ non sia sicuro secondo la definizione \ref{sistemaSicuro1}, si può affermare che al passo 5 del gioco probabilistico, lo steganalista sia in grado di rispondere correttamente al problema della decisione steganografica su $S$ con probabilità non trascurabile, ovvero saprà determinare con probabilità maggiore del 50\% se $x_0 \, = \, 0$ oppure no. Questo vuol dire che anche $P_1$, che simula $P$, può farlo. $\mathrm{\grave{E}}$ stato quindi costruito un algoritmo probabilistico $P_1$ che, in tempo polinomiale, è in grado di decidere se il valore del bit meno significativo di una stringa cifrata con l'RSA è 0 o 1. Ciò, come visto all'inizio della sezione corrente, equivale ad aver trovato un algoritmo polinomiale che attacca con successo l'RSA, il che dà luogo ad un assurdo. In seguito a quanto descritto si può affermare che un sistema steganografico $S$ che usa la tecnica di LSB-modification con funzione di embedding è da considerarsi probabilisticamente sicuro, intendendo dire che uno steganalista, che sia in possesso di un oracolo steganografico e uno di valutazione strutturale su $S$, non sarà in grado di decidere, con probabilità non trascurabile, se una generica immagine è una cover o uno stego-oggetto creato con $S$.\\
Tuttavia, considerando che la sicurezza probabilistica non implica necessariamente la sicurezza teoretica \cite{sec}, verrà  mostrato come sia possibile ricavare informazioni utili circa stego-oggetti creati con un sistema steganografico che fa uso di LSB-modification tramite metodi di steganalisi. 